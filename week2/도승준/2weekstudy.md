## 시간 복잡도의 비교.

order가 각각 o(f(n)), o(g(n))인 알고리즘 F,G를 비교할때,
g(n)/f(n)을 lim을 사용해 극한으로 보냈을 때,
### 1. 값이 0이면
알고리즘 G가 알고리즘 F보다 우수한 것이고,

### 2. 값이 상수이면
알고리즘 G,F는 우열을 가릴수 없다.(하드웨어, 소프트웨어 성능에 따라 변할 수 있기 때문에)

### 3. 값이 무한대이면
알고리즘 F가 알고리즘 G보다 우수하다.

---------------------------------------------------------------------------------

## 시간 복잡도 T(n)을 어떻게 표현하는 것이 가장 좋을까?
- T(n) = O(f(n))에서 f(n)은 T(n)에서 가장 고차단항이면서 계수가 1인 식으로 표현한다.
즉 , f(n)/T(n)의 n을 극한으로 보냈을때 단항이면서 계수가 1인 식으로 표현하는 것이 좋다.
예를 들면, T(n)이 = 5n^4 + 4n^3 + n 이라고 했을 때, 
f(n) = O(n^4)인 것이다.

---------------------------------------------------------------------------------------

## 이를 알았음에도 어느 알고리즘이 우수한지 모르겠어요 !

그럴 떄는 로피탈의 정리를 써서 미분을 해보자.
n을 극한으로 보낼 때, f(n)/g(n) = f'(n)/g'(n) 인 것이 로피탈의 정리이다.


## 알고리즘 분석 예시

- 과거의 주식 가격이 주어졌을 때, 과거 어느 시점에서 그 주식을 구매하고, 어느 시점에서 매각하는 것이 가장 최대의 이익을
얻을 . 수있는가? 또한 그떄의 최대 이익은 얼마인가?


### sol1
브루트 포스를 써서 풀 수 있다. 모든 구간에 대하여 그 구간의 합을 계산하고, 이 합들 중에서 가장 큰 합을 계산한다
시간 복잡도가 n^3이기 때문에 그다지 좋은 방법은 아니다.

### sol2 
알고리즘 1에서 좀 더 발전시킨 방법. 끝 부분의 합을 미리 알고 있으므로 그를 이용해 loop를 덜 돌게 된다.
-시간 복잡도 n^2으로 감소

### sol3
start(구간의 시작 부분), end(구간의 끝 부분)을 변수로 두고, 초깃값을 -1로 설정한다음 loop에서 i,j 
두 변수를 사용해 i-j까지의 합이 현재 최댓값보다 높으면 최댓값으로 설정하고 start와 end의 값을 각각 i,j로 맞추고,
그렇지 않다면 i의 값을 j+1로 만들고, 다시 루프를 도는 방법이다.
이 방법을 Kadane's linear algorithm이라고 한다.
이 방법을 사용하면 O(n)의 시간 복잡도로 문제를 해결할 수 있어 여타 풀이들보다 아주 우수하다고 할 수 있다 !!!

